
/* dx_kernel.h : DoneX内核调度头文件. Combo.xy 2009-10-18 13:24:09 Home */

#ifndef _DX_KERNEL_H_
#define _DX_KERNEL_H_

#include "../../h/donex.h"


#ifdef __cplusplus
extern "C" {
#endif


/********************************************************************************
 * 优先级数量和长度
 ********************************************************************************/
#define DX_PRIO_COUNT  (DX_PRIO_MAX+1)                          /* 优先级个数 */
#define DX_PRIO_TABLE ((DX_PRIO_MAX/8)+1)                       /* 优先级调度表长度 */


/********************************************************************************
 * 优先级索引
 ********************************************************************************/
#if     DX_PRIO_MAX < 64
#define DX_PRIO_INDEX   DX_U8                                   /* 优先级索引(8位) */
#elif   DX_PRIO_MAX < 128
#define DX_PRIO_INDEX   DX_U16                                  /* 优先级索引(16位) */
#elif   DX_PRIO_MAX < 256
#define DX_PRIO_INDEX   DX_U32                                  /* 优先级索引(32位) */
#else
#error 'DX_PRIO_MAX' defined error!
#endif


/********************************************************************************
 * 内核栈大小 (大小根据测试后设置)
 ********************************************************************************/
#define DX_STACK_SIZE_KERNEL    2048                            /* 内核栈大小 */
#define DX_STACK_SIZE_ISR       2048                            /* 中断服务程序栈大小 */


/********************************************************************************
 * 调度编码和解码地图 (快速索引到最高优先级的bit位)
 ********************************************************************************/
#if DX_SCHED_WAY == DX_FIRST_MEM
extern  DX_U32          dx_sched_encode_map[32];                /* 调度编码地图 */
#endif
#if DX_SCHED_WAY == DX_FIRST_MEM || DX_SCHED_WAY == DX_FIRST_AUT
extern  DX_U8           dx_sched_decode_map[256];               /* 调度解码地图 */
#endif


/********************************************************************************
 * 优先级调度表 (调度索引表示对应字节[8bits组]是否有值或者无值)
 ********************************************************************************/
extern  DX_U8           dx_prio_sched_table[DX_PRIO_TABLE];     /* 优先级调度表 */
extern  DX_PRIO_INDEX   dx_prio_sched_index;                    /* 优先级调度索引 */


/********************************************************************************
 * 内核参数
 ********************************************************************************/
typedef struct DX_KERNEL_PARA_S {
    int tick_irq;                                               /* tick中断号 */
    int tick_interval;                                          /* tick中断间隔 */
} DX_KERNEL_PARA;
extern  DX_KERNEL_PARA  dx_kernel_para;                         /* 内核参数 */


/********************************************************************************
 * 中断向量表
 ********************************************************************************/
extern  VOIDFUNC        dx_int_vector[DX_INT_MAX];              /* 中断向量表 */


/********************************************************************************
 * 内核锁引用计数 (防止递归锁中断操作后直接解锁)
 ********************************************************************************/
extern  int             dx_kernel_lock_counter[DX_CPU_MAX];


/********************************************************************************
 * 调度规则 - 调度编码和解码 (使用快速表值地图法来确定最高的优先级) [可配置支持'N'个优先级]
 *  1. 编码 : 把0~(N-1)的数值映射到节点数量为N的BIT数组中, 有值的bit为1, 无值的bit为0;
 *  2. 解码 : 找出最小为1的bit位, 通过查照对应的数值表(无循环,但数值表需要2^N那么大);
 *  3. 方法 : 
 *          将数值的低3bit位看作是BIT数组的字节值,(单字节内的第几个bit)
 *          将数值的高5bit位看作是BIT数组的索引值,(整体的第几个字节),
 *          因此编码就是把数值的低3位和高5位进行分拆, 转换成对应的bit位置,
 *          添加到BIT数组中高5位对应的字节索引位置的字节中; 对应解码就是把
 *          BIT数组中的字节先为非0的位置找到, 然后把该字节最先为1的bit位转
 *          换为数值的低3位, 把之前字节非0的位置看作高5位, 然后组合成完整的
 *          数值;(因此,除数组外还需要一个索引, 用来记录数组的数字是否为非0)
 *  4. 说明 : 
 *          不一定全部使用高5位(0-255), 还可以使用:
 *          高4位(0-127), 高3位(0-64).
 *          通过索引和bit组的结合，数值地图始终只用得到256大小.
 * 
 * 调度索引(index) / 调度表(table) / 优先级(prio) : 
 *                                                            (优先级高5位数值对应的索引bit)
 * [prio-index]             ... 1 0 0 1 ... <------------------------+
 *                              |     |                              |
 *                     +--------+     +-----------+                01000 | 010  [优先级值]
 *                     |                          |                         |
 * [prio-table] ... 10010011 00000000 00000000 00110000 ... <---------------+
 *                                                            (优先级低3位数值对应节点内bit)
 ********************************************************************************/


/* 获取数值映射到BIT数组的字节值(低3位)和索引值(高5位) */
#define DX_SCHED_BYTE_VALUE(num)            ( (num)     & 0x07)
#define DX_SCHED_BYTE_INDEX(num)            (((num)>>3) & 0x1F)

/* 编码 */
#if     DX_SCHED_WAY == DX_FIRST_CPU || DX_SCHED_WAY == DX_FIRST_AUT
#define DX_SCHED_ENCODE(val)                (1<<(val))
#else
#define DX_SCHED_ENCODE(val)                dx_sched_encode_map[val]
#endif

/* 解码(8位) */
#if     DX_SCHED_WAY == DX_FIRST_CPU
extern  DX_U8 dx_sched_decode_8(DX_U8 val);
#define DX_SCHED_DECODE_8(val)              dx_sched_decode_8(val)
#else
#define DX_SCHED_DECODE_8(val)              dx_sched_decode_map[val]
#endif

/* 解码(16位) */
#if     DX_SCHED_WAY == DX_FIRST_CPU || DX_SCHED_WAY == DX_FIRST_AUT
extern  DX_U8 dx_sched_decode_16(DX_U16 val);
#define DX_SCHED_DECODE_16(val)             dx_sched_decode_16(val)
#else
#define DX_SCHED_DECODE_16(val)                                                 \
    (dx_sched_decode_map[(val)&0xFF] != 0xFF)?                                  \
        dx_sched_decode_map[(val)&0xFF] : (                                     \
        (dx_sched_decode_map[((val)>>8)&0xFF] != 0xFF)?                         \
            (dx_sched_decode_map[((val)>>8)&0xFF] + 8) : 0xFF                   \
        )
#endif

/* 解码(32位) */
#if     DX_SCHED_WAY == DX_FIRST_CPU || DX_SCHED_WAY == DX_FIRST_AUT
extern  DX_U8 dx_sched_decode_32(DX_U32 val);
#define DX_SCHED_DECODE_32(val)             dx_sched_decode_32(val)
#else
#define DX_SCHED_DECODE_32(val)                                                 \
    (dx_sched_decode_map[(val)&0xFF] != 0xFF)?                                  \
        dx_sched_decode_map[(val)&0xFF] : (                                     \
        (dx_sched_decode_map[((val)>>8)&0xFF] != 0xFF)?                         \
            (dx_sched_decode_map[((val)>>8)&0xFF] + 8) : (                      \
            (dx_sched_decode_map[((val)>>16)&0xFF] != 0xFF)?                    \
                (dx_sched_decode_map[((val)>>16)&0xFF] + 16) : (                \
                (dx_sched_decode_map[((val)>>24)&0xFF] != 0xFF)?                \
                    (dx_sched_decode_map[((val)>>24)&0xFF] + 24) : 0xFF         \
                )                                                               \
            )                                                                   \
        )
#endif

/* 解码 */
#if     DX_PRIO_MAX < 64
#define DX_SCHED_DECODE(val)    DX_SCHED_DECODE_8(val)
#elif   DX_PRIO_MAX < 128
#define DX_SCHED_DECODE(val)    DX_SCHED_DECODE_16(val)
#elif   DX_PRIO_MAX < 256
#define DX_SCHED_DECODE(val)    DX_SCHED_DECODE_32(val)
#else
#error 'DX_PRIO_MAX' defined error!
#endif
/********************************************************************************/


/********************************************************************************
 * 栈内存分布
 *  +-------------------------+
 *  |     kernel objects      |
 *  +-------------------------+              +---------+------------+
 *  |     kernel stack        | <----------- | context | call stack |
 *  +-------------------------+              +---------+------------+
 *  |     isr stack (cpu 0)   | <---+------- | context | call stack |
 *  +-------------------------+     |        +---------+------------+
 *  |     isr stack (cpu 1)   | <---+ (cpu lists)
 *  +-------------------------+     |
 *  |     isr stack (cpu ...) | <---+
 *  +-------------------------+
 *  |     ... ...             |
 *  +-------------------------+              +------+-----+------+---------+------------+
 *  |     task stack          | <---+------- | name | TCB | vars | context | call stack |
 *  +-------------------------+     |        +------+-----+------+---------+------------+
 *  |     task stack          | <---+ (task lists)
 *  +-------------------------+     |
 *  |     ... ...             | <---+
 *  +-------------------------+
 *  |     heap                |
 *  +-------------------------+
 *  |     ... ...             |
 *  +-------------------------+
 ********************************************************************************/


/********************************************************************************
 * 栈内存管理
 *  |
 *  +--------------+-------------------------------+
 *  | MEM OBJ HEAD | kernel objects (basic)        | (相对固定的内存区)
 *  +--------------+-------------------------------+
 *  |
 *  +--------------+-------------------------------+
 *  | MEM OBJ HEAD | isr stack (cpus ... )         | (按照CPU数量变化)
 *  +--------------+-------------------------------+
 *  |
 *  +--------------+-------------------------------+
 *  | MEM OBJ HEAD | task stack (tasks ... )       | (按照任务数量变化)
 *  +--------------+-------------------------------+
 *  |
 *  +--------------+-------------------------------+
 *  | MEM OBJ HEAD | dynamic using ...             | 
 *  +--------------+-------------------------------+
 ********************************************************************************/


/********************************************************************************
 * 内核对象类型
 ********************************************************************************/
enum {
    DX_OBJ_TYPE_MEM = 0,                                        /* 内存对象 */
    DX_OBJ_TYPE_TASK,                                           /* 任务对象 */
    DX_OBJ_TYPE_LOCK,                                           /* 互斥锁对象 */
    DX_OBJ_TYPE_EVENT,                                          /* 事件对象 */
    DX_OBJ_TYPE_COUNTER,                                        /* 计数器对象 */

    DX_OBJ_TYPE_COUNT                                           /* 对象数量 */
};


/********************************************************************************
 * 内核对象控制块
 ********************************************************************************/
typedef struct DX_OBJ_S {
    char                magic[2];                               /* 魔术字 */
    DX_U8               offset;                                 /* 对象偏移 */
    DX_U8               type;                                   /* 对象类型 */
    DX_SIZE             size;                                   /* 对象大小 */
} DX_OBJ;


/********************************************************************************
 * 进入和退出内核临界区
 ********************************************************************************/
extern  void        dx_kernel_enter();                          /* [函数]锁定所有CPU中断 */
extern  void        dx_kernel_leave();                          /* [函数]解锁所有CPU中断 */
extern  void        dx_kernel_lock  (int cpu);                  /* [函数]锁定单个CPU中断 */
extern  void        dx_kernel_unlock(int cpu);                  /* [函数]解锁单个CPU中断 */


/********************************************************************************
 * 进入和离开就绪状态、以及获取最高就绪优先级
 ********************************************************************************/
extern  void        dx_ready_enter(DX_U8 prio);                 /* [函数]优先级进入就绪状态 */
extern  void        dx_ready_leave(DX_U8 prio);                 /* [函数]优先级离开就绪状态 */
extern  DX_U8       dx_ready_sched();                           /* [函数]优先级调度 (获取要运行的最高优先级) */


/********************************************************************************
 * 内核初始化 (tick中断向量号,tick毫秒时间)
 ********************************************************************************/
extern  void        dx_kernel_init(DX_KERNEL_PARA *para);       /* 内核初始化接口 */


/********************************************************************************
 * 内核对象初始化
 ********************************************************************************/
extern  DX_OBJ *    dx_object_init(                             /* [函数]内核对象初始化 */
                        void *addr, DX_SIZE size,               /* [输入]缓冲区地址和大小 */
                        DX_U8 offset,                           /* [输入]对象偏移 */
                        DX_U8 type);                            /* [输入]对象类型 */
extern  void *      dx_object_handle(                           /* [函数]获取对象句柄 (如果是正确的对象) */
                        DX_OBJ *obj);                           /* [输入]对象地址 */

/* 内核定时调度 */
void    dx_kernel_tick();


#ifdef __cplusplus
}
#endif

#endif /* #ifndef _DX_KERNEL_H_ */
